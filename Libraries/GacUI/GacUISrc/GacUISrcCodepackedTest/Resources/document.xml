<Doc><Content><p><font face="Cambria" size="24" color="#4B4B4B"><b>Vczh Library++ 语法分析器开发指南</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">陈梓瀚</font><br/></p><p><font face="Calibri" size="32" color="#000000"><b>前言</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">在日常的开发工作中我们总是时不时需要写一些语法分析器。语法分析器不一定指的是一门语言的编译器前端，也有可能仅仅是一个自己设计格式的配置文件的读写程序，或者是一门用来简化我们开发的DSL（领域专用语言）。我们可以选择使用XML，不过因为XML的噪音实在是太多，所以自己写语法分析器在有些情况下是必要的，特别是那种经常需要修改的文件，使用XML有时候会增加我们的负担，除非我们专门为此开发一个编辑器程序。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">这篇文章将紧密结合一个带函数的四则运算计算器的例子（</font><font face="Calibri" size="16" color="#0000FF">Documentation\Samples\ExpressionCalculator\ExpressionCalculator.sln</font><font face="Calibri" size="16" color="#4B4B4B">）来说明如何使用Vczh Library++提供的工具来大幅度简化我们的语法分析器的开发，并最终给出一个可以编译的例子。虽然这个例子实在是老掉牙了，不过开发一个四则运算计算器可以覆盖大部分开发语法分析的过程中会遇到的问题，所以也不失为一个好的例子。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">这个例子可以在</font><font face="Calibri" size="16" color="#1A8BC8">Vczh Library++的代码</font><font face="Calibri" size="16" color="#4B4B4B">里面找到。</font><br/></p><p><font face="Calibri" size="32" color="#000000"><b>制定语法</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">我们需要对带函数的四则运算计算器下一个定义，这样我们才可以有目的地完成这个任务。我们对四则运算式子是很熟悉的，一个四则运算式子包含加减乘除、括号和数字。我们还可以支持负号：-a，其实是(0-a)的简写形式。那么什么是支持函数呢？这里我们只考虑单参数函数的情况，譬如说三角函数和对数指数等等。譬如说下面的式子就是满足定义的带函数的四则运算式子：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>sin(1+2) + cos(3*-4)</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">Vczh Library++使用语法的角度来对待一个字符串，因此我们可以把上面的定义转换成语法。一个语法用来表示字符串的一个子集。我们可以通过语法来表达什么样的字符串是满足规定的，什么样的字符串是不满足规定的。不过一个具有现实意义的语法总是会有一些局限性的，譬如说你很难用上下文无关的文法来表达一个字符串：a…ab…bc…c，其中三种字母的数量都相等。幸好在绝大多数情况下我们都不需要去面对这些高难度的问题，因此可以用一些简单的规则来处理：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>RULE = EXPRESSION</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">RULE是这个规则的名字，而EXPRESSION是这个规则的定义。语法可以由一条规则组成，也可以由很多条规则组成。当所有的规则都列出来之后，那么每一个规则的名字都是一个字符串的集合。大部分情况下你需要指定一个“总入口”来代表整个语法。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">举个例子，假设我们判断一个字符串是不是无符号整数。一个无符号整数只能由数字字符组成。于是我们可以先用一条规则来代表“数字字符”。这里我们可以使用“|”来代表“或”，那么下面的规则就表示DIGIT是’0’或’1’或…或’9’：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘0’ | ‘1’ | ‘2’ | ‘3’ | ‘4’ | ‘5’ | ‘6’ | ‘7’ | ‘8’ | ‘9’</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">那么，无符号整数就是“很多数字字符”：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = DIGIT | INTEGER DIGIT</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">无符号整数INTEGER要么是一个数字字符，要么就是一个合法的无符号整数后面再加上一个数字字符。无符号整数加上一个数字字符仍然是一个无符号整数。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">现在可以来检验一下。譬如说“1”是一个无符号整数，那么从INTEGER开始，分析“1”所走的路径就是</font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>INTEGER</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= DIGIT					(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’						(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘1’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">字符串“123”显然也应该是一个无符号整数。“123”是</font><font face="Calibri" size="16" color="#4B4B4B"><b>一些</b></font><font face="Calibri" size="16" color="#4B4B4B">数字字符组成的，因此走的路径跟单个字符稍微有些不同。这里将会交替使用INTEGER的两条路径来模拟循环：</font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>INTEGER</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= INTEGER DIGIT			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = INTEGER DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= INTEGER DIGIT DIGIT		(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = INTEGER DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= DIGIT DIGIT DIGIT		(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ DIGIT DIGIT			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘1’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘2’ DIGIT				(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘2’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘2’ ‘3’				(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘3’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">在使用INTEGER分析“123”的时候，我们可以交替使用INTEGER = DIGIT和INTEGER = INTEGER DIGIT这两条规则来将一个INTEGER替换成恰好三个DIGIT，然后再将DIGIT替换成’1’、’2’和’3’三个字符，从而确信“123”满足INTEGER的定义，因此“123”是一个无符号整数。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">替换的过程并不是唯一的，我们完全可以使用另一种顺序来将INTEGER替换成“123”：</font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>INTEGER</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= INTEGER DIGIT			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = INTEGER DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= INTEGER ‘3’				(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘3’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= INTEGER DIGIT ‘3’		(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = INTEGER DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= INTEGER ‘2’ ‘3’			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘2’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= DIGIT ‘2’ ‘3’				(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘2’ ‘3’				(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘1’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">这正是语法的一个特点：替换顺序与结果无关。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">现在我们将这个例子再深入一点，如何用语法规则来描述一个逗号分隔的无符号整数列表呢？逗号分隔的无符号整数列表可以是一个整数“123”，也可以使多个整数“1,23,456”。这也是重复的一种，只是跟INTEGER的那种重复有所区别——多了一个逗号。根据上面的描述可以知道，逗号分隔的无符号整数列表有两种情况，第一种是单独的一个整数，第二种是一个已经完成的列表后面跟着一个逗号和一个整数。那么事情就变得简单了。假设我们使用LIST来代表这个列表，那么根据上面的描述我们可以用类似的技巧来描述它：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>LIST = INTEGER | LIST ‘,’ INTEGER</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">用LIST来分析一个数字列表的过程与用INTEGER分析一个无符号整数是相似的。因为篇幅问题，这里只展示使用LIST处理“1,23,456”的其中一种方法：</font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>LIST</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= LIST ‘,’ INTEGER						(</b></font><font face="Calibri" size="16" color="#0070C0"><b>LIST = LIST ‘,’ INTEGER</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= LIST ‘,’ INTEGER ‘,’ INTEGER				(</b></font><font face="Calibri" size="16" color="#0070C0"><b>LIST = LIST ‘,’ INTEGER</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= INTEGER ‘,’ INTEGER ‘,’ INTEGER			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>LIST = INTEGER</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= DIGIT ‘,’ INTEGER ‘,’ INTEGER			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ INTEGER ‘,’ INTEGER				(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘1’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ INTEGER DIGIT ‘,’ INTEGER			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = INTEGER DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ DIGIT DIGIT ‘,’ INTEGER			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ ‘2’ DIGIT ‘,’ INTEGER				(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘2’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ ‘2’ ‘3’ ‘,’ INTEGER					(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘3’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ ‘2’ ‘3’ ‘,’ INTEGER DIGIT			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = INTEGER DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ ‘2’ ‘3’ ‘,’ INTEGER DIGIT DIGIT		(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = INTEGER DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ ‘2’ ‘3’ ‘,’ DIGIT DIGIT DIGIT			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>INTEGER = DIGIT</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ ‘2’ ‘3’ ‘,’ ‘4’ DIGIT DIGIT			(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘4’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ ‘2’ ‘3’ ‘,’ ‘4’ ‘5’ DIGIT				(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘5’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#C00000"><b>= ‘1’ ‘,’ ‘2’ ‘3’ ‘,’ ‘4’ ‘5’ ‘6’					(</b></font><font face="Calibri" size="16" color="#0070C0"><b>DIGIT = ‘6’</b></font><font face="Calibri" size="16" color="#C00000"><b>)</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">在开发实际的语法分析器的时候，我们总是需要考虑空格的问题。人们用空格让一个具有严格限制的字符串变得更加易读，譬如说将“1,23,456”变成“1, 23, 456”会让密密麻麻的一堆字符变得非常容易看懂。空格也不是乱加的，有些地方可以加空格，有些地方不能加空格。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">在上面这个例子里面，如果要支持空格，那么空格除了不能插在INTEGER中间，应该可以放在任何的地方。这个时候就带来麻烦了，带空格的语法不是太好写。如果我们让LIST支持空格，那会把LIST变成下面这个样子：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>SPACES = &lt;EMPTY&gt; | SPACES ‘ ’</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>LIST = SPACES INTEGER SPACES | LIST ‘,’ SPACES INTEGER SPACES</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">这里&lt;EMPTY&gt;代表空字符串，所以SPACES就是没有空格、一个空格或者很多空格了。因此我们必须在LIST里面所有可以加入空格的地方写空格，这会让我们的语法膨胀得很厉害。因此我们必须使用一种方法来让我们免除空格带来的困扰。</font><br/></p><p><font face="Calibri" size="32" color="#000000"><b>词法分析</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">引入词法分析的目的是让我们的语法更加简洁。我们可以将处理空格、注释和分割字符串的工作与语法分析完全分开，那么代码写起来就会更加容易，维护起来也会更加简单了。我们总是倾向于让我们的程序越来越容易理解和维护。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">词法分析的目标是将输入的字符串适当分割并抛弃处理掉没有用的部分。“适当分割”一般来说没有一个明确的规则，应该根据具体情况而定，越方便越好。在大部分情况下我们仅把输入的字符串简单的划分为符号、数字、操作符、字符串、空格和注释等等的简单部分。这些划分一般代表“插入空格会改变意义”。比如说“1234”变成“12 34”之后，就从一个整数变成两个整数了。字符串的情况有点特别，虽然字符串中间插入一个空格还是一个字符串，但是插入空格后的字符串已经不是插入空格前的字符串了，因为内容已经发生了变化。与此同时，在一个整数列表里面，往逗号后面插入一个空格不会影响这个列表所要表达的意义，因此将字符串转换成“整数列表”的工作一般划分在语法分析而不是词法分析里。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">处理词法分析的方法一般是使用正则表达式。Vczh Library++提供了一个使用正则表达式来开发词法分析器的类库。关于正则表达式的语法请参考</font><font face="Calibri" size="16" color="#0000FF">Documentation\Chinese\Vczh Library++\Regex\Regex.htm#Grammar</font><font face="Calibri" size="16" color="#4B4B4B">，关于这个词法分析器类的内容请参考</font><font face="Calibri" size="16" color="#0000FF">Documentation\Chinese\Vczh Library++\Regex\Regex.htm#RegexToken</font><font face="Calibri" size="16" color="#4B4B4B">。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">在使用Vczh Library++进行词法分析的开发之前需要掌握正则表达式的简单用法。这里我们假设读者对正则表达式已经入门了。精通是没有必要的，因为词法分析使用到的正则表达式的内容十分简单。我们回到之前的“带函数的四则运算计算器”。经过简单的整理，我们知道一个带函数的四则运算计算器由数字、函数名、操作符和符号组成。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">加号与减号的优先级一样，对于语法分析来说他们其实没有区别。乘号与除号也类似。当语法分析结束，语义分析开始的时候，加号与减号的区别才会出现。因此在词法分析里面我们可以把他们当成同样的东西来对待，因此有：</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">BLANK = \s+				：空格</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">ADD = \+|-				：加减号</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">MUL = \*|/				：乘除号</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">NUMBER = \d+(.\d+)?		：数字</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">ID = [a-zA-Z_]\w*			：函数名</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">OPEN = \(					：开括号</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">CLOSE = \)				：闭括号</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">我们把分类后的结果叫</font><font face="Calibri" size="16" color="#4B4B4B"><b>记号类型</b></font><font face="Calibri" size="16" color="#4B4B4B">。一个字符串可以被分成很多记号，每一个</font><font face="Calibri" size="16" color="#4B4B4B"><b>记号</b></font><font face="Calibri" size="16" color="#4B4B4B">属于一个</font><font face="Calibri" size="16" color="#4B4B4B"><b>记号类型</b></font><font face="Calibri" size="16" color="#4B4B4B">。如果一个记号不属于任何记号类型的话（譬如问号“?”），那么遇到了词法分析的错误。这个时候我们需要报告错误了。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">Vczh Library++有一个简单的方法让我们是用正则表达式表达记号类型，并使用他们来构造词法分析器：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#4B4B4B"><b>List</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>WString</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt; patterns;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> BLANK		= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/s+&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> ADD			= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/+|-&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> MUL			= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/*|//&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> NUMBER		= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/d+(./d+)?&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> ID			= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;[a-zA-Z_]/w*&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> OPEN		= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/(&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> CLOSE		= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/)&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexLexer</b></font><font face="新宋体" size="12" color="#4B4B4B"> lexer(patterns.Wrap());</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">为了方便书写正则表达式，Vczh Library++同时支持两种转义符：“\”和“/”。因为C++使用了“\”作为字符串的转义符，所以在这里我们可以使用“/”，这样写起来会比较清晰。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">构造词法分析器的方法很简单，我们将所有正则表达式放到一个字符串列表List&lt;WString&gt;，然后交给词法分析器RegexLexer，我们就得到了一个词法分析器了。在分析字符串的时候，每一个记号的类型其实就是该记号的正则表达式描述在字符串列表中的位置。如果发生错误的话，记号类型会变成-1。因为列表的Add函数返回添加的元素在列表中的位置，因此就可以使用上面的写法来简单地构造一个词法分析器了。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">我们可以用一种简单的方法来使用这个词法分析器。RegexLexer输出的记号存放在RegexToken类型里面，我们可以使用任何容器来存放记号，在这里我们仍然使用RegexToken。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">RegexToken的定义如下：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">class</font><font face="新宋体" size="12" color="#4B4B4B"> RegexToken</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">public</font><font face="新宋体" size="12" color="#4B4B4B">:</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B">				start;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B">				length;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B">				token;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">wchar_t</font><font face="新宋体" size="12" color="#4B4B4B">*	reading;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B">				lineIndex;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B">				lineStart;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B">				codeIndex;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">};</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">RegexToken记录了一个记号在输入的字符串中的位置、所在的行和在该行内的位置、记号类型和指向该位置的指针。这些信息可以用来做很多事情，譬如在产生错误信息的时候可以精确指定错误发生的位置。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">在这里我们需要过滤空格，也就是过滤掉BLANK记号，因此我们需要写一个过滤函数：</font><br/></p><p><font face="新宋体" size="12" color="#0000FF">bool</font><font face="新宋体" size="12" color="#4B4B4B"> IsNotBlank(</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B"> token)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> token.token!=0;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">}</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">我们知道BLANK就是0，因此这里直接以0代替。有了这个函数之后，我们就可以将输入切割成记好了：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B"><b>List</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt; tokens;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">CopyFrom(tokens.Wrap(), lexer.Parse(L</font><font face="新宋体" size="12" color="#A31515">&quot;(1 + 2) * abs(-3 - 4)&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)&gt;&gt;Where(IsNotBlank));</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">执行了这段代码之后，我们就将字符串切割成记号了。这里只用了15行就完成了词法分析器的定义并使用词法分析器来分析一个字符串的任务了。</font><br/></p><p><font face="Calibri" size="16" color="#FF0000"><b>注意</b></font><font face="Calibri" size="16" color="#4B4B4B">：如果将一个字符指针传入lexer.Parse的话，在获得记号列表之后将这个字符指针删除，那么所有记号中的reading将全部变成野指针。lexer.Parse的参数是WString类型，所以这个例子在执行之后，临时的字符串对象会被删除，因此记号列表中的所有reading成员将全部变成野指针。</font><font face="Calibri" size="16" color="#FF0000"><b>因此在实践过程中最好先使用一个WString变量去保存输入的字符串，然后将这个变量传入lexer.Parse，之后所有reading成员将指向这个变量内部的一个有效指针。</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">这个时候我们就可以使用tokens里面的信息来做处理了。不过Vczh Library++还提供了语法分析器的类库，让我们可以不用亲自遍历这些记号。</font><br/></p><p><font face="Calibri" size="32" color="#000000"><b>带函数四则运算式子的语法</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">到了这里，我们可以把数字、函数名和符号当成已经存在的东西来看待了，而且再也不需要考虑空格的问题了。于是我们可以仔细组织带函数四则运算式子的语法：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = NUMBER</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = ‘-‘ FACTOR</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = ‘(‘ EXP ‘)’</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = ID ‘(‘ EXP ‘)’</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>TERM = FACTOR | TERM MUL FACTOR</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = TERM | EXP ADD TERM</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">语法的设计直接反映了我们的思考过程。这是一个带有递归的语法。当我们考虑下面的式子的时候</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>1*(2+2)*3+4*5*sin(6)+7*8*9</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">我们首先使用加减法将式子分割为三个部分</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>1*(2+2)*3 + 4*5*sin(6) + 7*8*9</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">然后使用乘除法将式子分割为九个部分，然后我们发现(2+2)和sin(6)他们是一个整体。不过整体仍然是由部分构成的，因此内部还包含表达式。所以不难看出，这里的FACTOR代表“整体”，TERM代表乘除法构成的“第二层表达式”，EXP代表加减法构成的“第一层表达式”。这个语法同时还代表“先乘除后加减”的计算原则。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">但是这里还有一个问题，我们观察一下EXP = TERM | EXP ADD TERM这条规则。我们不难发现他们其实是独立的两条规则的组合：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = TERM</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = EXP ADD TERM</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">第二条EXP的规则仍然从EXP开始，这种递归称为</font><font face="Calibri" size="16" color="#4B4B4B"><b>左递归</b></font><font face="Calibri" size="16" color="#4B4B4B">。左递归直接处理起来比较困难，因为你分析到EXP的时候很容易陷入一个死循环，因此我们需要拆开它们。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">我们引入扩展规则的机制来解决这个问题。如果我们想表达一个循环的话，我们不得不专门为它建立一条规则并命名：</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">LIST = ITEM | LIST ITEM</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">如果我们可以简化成LIST = ITEM+的话，就不需要专门为它起一个名字LIST了，而可以直接在各个地方使用ITEM+。跟正则表达式一样，我们使用+和*来代表循环。因此EXP就可以被改写成EXP = TERM ( ADD TERM)*了。注意(与’(‘的区别，’(‘代表一个字符，而(跟平常一样用来规定优先级，譬如这里代表重复“*”的范围。于是我们可以重新组织语法：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = NUMBER</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = ‘-‘ FACTOR</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = ‘(‘ EXP ‘)’</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = ID ‘(‘ EXP ‘)’</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>TERM = FACTOR (MUL FACTOR)*</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = TERM (ADD TERM)*</b></font><br/></p><p><font face="Calibri" size="32" color="#000000"><b>语法类型与C++表达</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">Vczh Library++允许我们直接把语法在C++的框架下表达出来，因此我们不得不对语法的表达形式做一点修改使之可以满足C++的要求。所以这里我们需要做两件事情，第一件事情是规则的类型，第二件事情是如何用C++语句来表达规则。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">规则的类型含义比较复杂，一个规则的类型不仅取决于它自身，还取决于它的产出。如果我们用语法规则来将记号直接转换成计算结果，那么一般来说规则的类型就是计算结果的类型，譬如说数字。如果我们用语法规则来讲记号转换成四则运算式子的语法树，那么规则的类型就是语法树节点的指针。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">如果我们把规则看成一个函数的话，那应该会更加容易理解。一个语法规则将输入的记号列表转换成我们需要的结果，所以规则的类型至少包含两个部分，一个是输入记号的类型，一个是输出类型。Vczh Library++专门为规则定义了一个模板类，而且这里FACTOR、TERM和EXP将会作为C++的变量直接声明出来。在这里我们希望语法规则能直接将输入转换成计算结果，结果的类型是double，输入的类型是RegexToken，因此我们可以这么声明三个规则的名字：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B"><b>Rule</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>TokenInput</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt;, </font><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B">&gt; factor, term, exp;</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">TokenInput是输入的其中一种表达形式，它可以将一个指针和长度转换成符合Rule输入的类型。Vczh Library++还同时提供了StringInput&lt;T&gt;和EnumerableInput&lt;T&gt;，但是我们已经将记号保存在List&lt;RegexToken&gt;里面了，因此使用TokenInput&lt;T&gt;是最合适的。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">StringInput&lt;T&gt;也好，EnumerableInput&lt;T&gt;也好，TokenInput&lt;T&gt;也好，其实都是一个迭代器。Vczh Library++的语法分析器类库为迭代器规定了一个接口，这三种迭代器都是在那个接口的框架下实现的。我们可以简单的把一个把TokenInput&lt;RegexToken&gt;套在List&lt;RegexToken&gt;上：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B"><b>TokenInput</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt; input(&amp;tokens[0], tokens.Count());</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">TokenInput在内部只保存了一个指针、长度和当前位置，所以是一个相当轻量级的类，可以到处复制并且不会有多少性能上的损失。不过TokenInput&lt;T&gt;的生命周期不应该比List&lt;T&gt;长，不然TokenInput&lt;T&gt;指向的对象会因为已经被释放掉而发生问题。同样的道理，在TokenInput&lt;T&gt;已经被套在List&lt;T&gt;上的时候，List&lt;T&gt;最好不要被修改。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">现在输入的类型已经清楚了，可以开始研究输出的类型了。上面的factor的声明是Rule&lt;TokenInput&lt;RegexToken&gt;, double&gt;，因此factor可以看成是一个输入迭代器TokenInput&lt;RegexToken&gt;，修改迭代器位置并输出double作为结果的函数。不过其实返回的实际类型是ParsingResult&lt;double&gt;，因为一个规则在分析一个迭代器输入的时候可能会产生错误，这个时候不能修改输入迭代器的位置，而且还要返回错误的标志。因此这里使用ParsingResult&lt;double&gt;，它能告诉你成功还是失败，而且成功的话会带有一个真正的double类型的返回值，并且修改迭代器的位置，让它指向跳过一个factor后的位置以便继续分析。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">规则有许多种组合方法。假设有规则：</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">Rule&lt;I, A&gt; a, a2;</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">Rule&lt;I, B&gt; b;</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">那么可以组合出以下各种新的规则：</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">a+b：类型Rule&lt;I, ParsingPair&lt;A, B&gt;&gt;，代表a和b应该按顺序出现。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">*a：类型Rule&lt;I, ParsingList&lt;A&gt;&gt;，代表a应该连续出现0或多次。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">+a：类型Rule&lt;I, ParsingList&lt;A&gt;&gt;，代表a应该连续出现1或多次。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">a|a2：类型Rule&lt;I, A&gt;，代表要么是a，要么是a2。这里a和a2类型应该一致。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">a&gt;&gt;b：类型Rule&lt;I, B&gt;，代表a和b应该按顺序出现，并且抛弃a只保留b的结果。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">a&lt;&lt;b：类型Rule&lt;I, A&gt;，代表a和b应该按顺序出现，并且抛弃b只保留a的结果。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">opt(a)：类型Rule&lt;I, A&gt;，代表a应该出现0或1次。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">还有另外两种组合方法，分别用于转换分析结果和进行错误恢复。在这里先介绍转换分析结果的组合方法。下面举EXP的例子：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = TERM (ADD TERM)*</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">写成C++应该是：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = TERM + *(tk(ADD) + TERM);</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">这里ADD的类型是const int，因此我们需要一个函数把它转换成一个规则。这里使用tk函数。tk函数将一个int转换成Rule&lt;TokenInput&lt;RegexToken&gt;, RegexToken&gt;，用于匹配一个输入是ADD类型的记号。于是我们可以慢慢解开这个规则的最终类型。这里我们不关心输入类型，只关心输出类型，因为所有的规则的类型都是Rule&lt;TokenInput&lt;RegexToken&gt;, T&gt;。根据上文，我们知道TERM与EXP的类型一样，都是返回double。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">tk(ADD)							：T == RegexToken</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">tk(ADD) + TERM					：T == ParsingPair&lt;RegexToken, double&gt;</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">*(tk(ADD) + TERM)					：T == ParsingList&lt;ParsingPair&lt;RegexToken, double&gt;&gt;</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">TERM + *(tk(ADD) + TERM)			：T == ParsingPair&lt;double, ParsingList&lt;ParsingPair&lt;RegexToken, double&gt;&gt;&gt;</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">这里问题就来了，EXP的类型跟TERM + *(tk(ADD) + TERM)类型不一样，那必然需要一个函数来帮我们做转换。假如我们已经有了一个函数：</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">double Operator(const ParsingPair&lt;double, ParsingList&lt;ParsingPair&lt;RegexToken, double&gt;&gt;&gt;&amp; input)</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">这个函数勇于将输入的那一大串东西，经过计算最终转换成一个double类型的结果，那么我们就可以使用这个Operator函数最终将EXP和TERM + *(tk(ADD) + TERM)连起来：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = (TERM + *(tk(ADD) + TERM))[Operator];</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">ParsingPair&lt;double, ParsingList&lt;ParsingPair&lt;RegexToken, double&gt;&gt;&gt;的内容实际上是一个操作数，加上一个操作符连着操作数的列表。于是当我们真的需要把它转成一个double的时候，就要去遍历所有“操作符连着操作数”的列表，最后将计算结果全部累加到第一个操作数身上。记得我们之前表达EXP的方法跟现在不一样吗？以前是</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = TERM | EXP ADD TERM</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">因为Vczh Library++无法处理左递归，才需要我们手动拆解成</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = TERM (ADD TERM)*</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">于是为了让我们处理起来更简单，Vczh Library++提供了一个lrec函数，让我们可以享受左递归带来的方便。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">lrec把类型ParsingPair&lt;T, ParsingList&lt;U&gt;&gt;通过一个函数T(const T&amp;, const U&amp;)转换成T。这就意味着一个输入T U U U … ，加上一个把一个T跟U加起来变成T的函数，最终把整个序列处理成T：</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">T U U U</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">=&gt; T U U</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">=&gt; T U</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">=&gt; T</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">如果把他们套到我们的EXP上面，就可以做下面的计算</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">TERM (ADD TERM) (ADD TERM) (ADD TERM)	</font><font face="Calibri" size="16" color="#FF0000"><b>1+2+3+4</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">=&gt; TERM (ADD TERM) (ADD TERM)			</font><font face="Calibri" size="16" color="#FF0000"><b>3+3+4</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">=&gt; TERM (ADD TERM)						</font><font face="Calibri" size="16" color="#FF0000"><b>6+4</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">=&gt; TERM									</font><font face="Calibri" size="16" color="#FF0000"><b>10</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">这个转换函数跟处理EXP ADD TERM是一样的！</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">因此，只要有了lrec函数，我们可以把</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = TERM | (EXP + tk(ADD) + TERM) [F1]</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">这种Vczh Library++不支持的左递归语法表示处理成</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = lrec(TERM + *(tk(ADD) + TERM), F2)</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">其中F1的类型是double (const ParsingPair&lt;ParsingPair&lt;double, RegexToken&gt;, double&gt;&amp;)</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">而F2的类型是double (const double&amp;, const ParsingPair&lt;RegexToken, double&gt;&amp;)</font><br/></p><p><font face="Calibri" size="16" color="#FF0000"><b>我们不会因为需要拆解左递归而带来任何不便！</b></font><br/></p><p><font face="Calibri" size="32" color="#000000"><b>实现</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">现在开始进入激动人心的时刻了，我们可以借助Vczh Library++来实现一个带函数四则运算式子的计算器了。现在回顾一下我们的语法：</font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = NUMBER</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = ‘-‘ FACTOR</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = ‘(‘ EXP ‘)’</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>FACTOR = ID ‘(‘ EXP ‘)’</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>TERM = FACTOR (MUL FACTOR)*</b></font><br/></p><p><font face="Calibri" size="16" color="#0070C0"><b>EXP = TERM (ADD TERM)*</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">把它转换成C++就应该是：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B"><b>Rule</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>TokenInput</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt;, </font><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B">&gt; factor, term, exp;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">factor	= tk(NUMBER) [</font><font face="新宋体" size="12" color="#FF0000"><b>Convert</b></font><font face="新宋体" size="12" color="#4B4B4B">]</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			| (tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;-&quot;</font><font face="新宋体" size="12" color="#4B4B4B">) &gt;&gt; factor)[</font><font face="新宋体" size="12" color="#FF0000"><b>Negative</b></font><font face="新宋体" size="12" color="#4B4B4B">]</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			| (tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;(&quot;</font><font face="新宋体" size="12" color="#4B4B4B">) &gt;&gt; exp &lt;&lt; tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;)&quot;</font><font face="新宋体" size="12" color="#4B4B4B">))</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			| (tk(ID) + (tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;(&quot;</font><font face="新宋体" size="12" color="#4B4B4B">) &gt;&gt; exp &lt;&lt; tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;)&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)))[</font><font face="新宋体" size="12" color="#FF0000"><b>Call</b></font><font face="新宋体" size="12" color="#4B4B4B">]</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	term		= lrec(factor + *(tk(MUL) + factor), </font><font face="新宋体" size="12" color="#FF0000"><b>Operator</b></font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">exp		= lrec(term + *(tk(ADD) + term), </font><font face="新宋体" size="12" color="#FF0000"><b>Operator</b></font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">让我们来逐个阅读规则，并分析出结果转换函数Convert、Negative、Call和Operator的类型。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">第一个是tk(NUMBER)[Convert]。这个规则将一个数字记号转换为一个真正的数字。因为tk(NUMBER)的类型是RegexToken，因此Convert的类型是</font><font face="Calibri" size="16" color="#0070C0"><b>double (const RegexToken&amp;)</b></font><font face="Calibri" size="16" color="#4B4B4B">。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">第二个是(tk(L”-“) &gt;&gt; factor)[Negative]。tk(L”-“)的类型是RegexToken，factor的类型是double，所以RegexToken&gt;&gt;double其实就是double。因此Negative的类型是</font><font face="Calibri" size="16" color="#0070C0"><b>double (const double&amp;)</b></font><font face="Calibri" size="16" color="#4B4B4B">。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">第三个是tk(L”(“) &gt;&gt; exp &lt;&lt; tk(L”)”)。实际上分析了两个括号和exp之后，括号被丢掉了，剩下exp的类型是double。因此这一行规则不需要任何转换函数。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">第四个是(tk(ID) + (tk(L”(“) &gt;&gt; exp &lt;&lt; tk(L”)”)))[Call]，我们很容易知道Call的类型是</font><font face="Calibri" size="16" color="#0070C0"><b>double(const ParsingPair&lt;RegexToken, double&gt;&amp;)</b></font><font face="Calibri" size="16" color="#4B4B4B">。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">最后一个是Operator，这个之前已经讨论过了，类型是</font><font face="Calibri" size="16" color="#0070C0"><b>double (const double&amp;, const ParsingPair&lt;RegexToken, double&gt;&amp;)</b></font><font face="Calibri" size="16" color="#4B4B4B">。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">知道了这个之后，我们就可以实现这些函数了：</font><br/></p><p><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B"> Convert(</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> RegexToken&amp; input)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> wtof(WString(input.reading, input.length));</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">}</font><br/></p><p><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B"> Negative(</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B">&amp; input)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> -input;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">}</font><br/></p><p><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B"> Operator(</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B">&amp; left, </font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> ParsingPair&lt;RegexToken, </font><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B">&gt;&amp; right)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">switch</font><font face="新宋体" size="12" color="#4B4B4B">(*right.First().reading)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">case</font><font face="新宋体" size="12" color="#4B4B4B"> L</font><font face="新宋体" size="12" color="#A31515">&apos;+&apos;</font><font face="新宋体" size="12" color="#4B4B4B">:</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> left+right.Second();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">case</font><font face="新宋体" size="12" color="#4B4B4B"> L</font><font face="新宋体" size="12" color="#A31515">&apos;-&apos;</font><font face="新宋体" size="12" color="#4B4B4B">:</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> left-right.Second();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">case</font><font face="新宋体" size="12" color="#4B4B4B"> L</font><font face="新宋体" size="12" color="#A31515">&apos;*&apos;</font><font face="新宋体" size="12" color="#4B4B4B">:</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> left*right.Second();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">case</font><font face="新宋体" size="12" color="#4B4B4B"> L</font><font face="新宋体" size="12" color="#A31515">&apos;/&apos;</font><font face="新宋体" size="12" color="#4B4B4B">:</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> left/right.Second();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">default</font><font face="新宋体" size="12" color="#4B4B4B">:</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> 0;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">}</font><br/></p><p><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B"> Call(</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> ParsingPair&lt;RegexToken, </font><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B">&gt;&amp; input)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		WString name(input.First().reading, input.First().length);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B"> parameter=input.Second();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;sin&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> sin(parameter);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;cos&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> cos(parameter);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;tan&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> tan(parameter);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;cot&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> 1/tan(parameter);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;sec&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> 1/cos(parameter);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;csc&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> 1/sin(parameter);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;exp&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> exp(parameter);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;ln&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> log(parameter);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;abs&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> abs(parameter);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;sqrt&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> sqrt(parameter);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(name==L</font><font face="新宋体" size="12" color="#A31515">&quot;sqr&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> parameter*parameter;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">else</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">throw</font><font face="新宋体" size="12" color="#4B4B4B"> Exception(L</font><font face="新宋体" size="12" color="#A31515">&quot;Function &quot;</font><font face="新宋体" size="12" color="#4B4B4B">+name+L</font><font face="新宋体" size="12" color="#A31515">&quot; not exists.&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">}</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">然后我们就可以用这些函数来构造一个语法分析器了：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#4B4B4B"><b>List</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>WString</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt; patterns;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> BLANK		= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/s+&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> ADD			= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/+|-&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> MUL			= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/*|//&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> NUMBER		= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/d+(./d+)?&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> ID			= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;[a-zA-Z_]/w*&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> OPEN		= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/(&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> CLOSE		= patterns.Add(L</font><font face="新宋体" size="12" color="#A31515">&quot;/)&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexLexer</b></font><font face="新宋体" size="12" color="#4B4B4B"> lexer(patterns.Wrap());</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#4B4B4B"><b>Rule</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>TokenInput</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt;, </font><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B">&gt; factor, term, exp;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	factor	= tk(NUMBER)[</font><font face="新宋体" size="12" color="#FF0000"><b>Convert</b></font><font face="新宋体" size="12" color="#4B4B4B">]</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			| (tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;-&quot;</font><font face="新宋体" size="12" color="#4B4B4B">) &gt;&gt; factor)[</font><font face="新宋体" size="12" color="#FF0000"><b>Negative</b></font><font face="新宋体" size="12" color="#4B4B4B">]</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			| (tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;(&quot;</font><font face="新宋体" size="12" color="#4B4B4B">) &gt;&gt; exp &lt;&lt; tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;)&quot;</font><font face="新宋体" size="12" color="#4B4B4B">))</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			| (tk(ID) + (tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;(&quot;</font><font face="新宋体" size="12" color="#4B4B4B">) &gt;&gt; exp &lt;&lt; tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;)&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)))[</font><font face="新宋体" size="12" color="#FF0000"><b>Call</b></font><font face="新宋体" size="12" color="#4B4B4B">]</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	term		= lrec(factor + *(tk(MUL) + factor), </font><font face="新宋体" size="12" color="#FF0000"><b>Operator</b></font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">exp		= lrec(term + *(tk(ADD) + term), </font><font face="新宋体" size="12" color="#FF0000"><b>Operator</b></font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B"><b>WString</b></font><font face="新宋体" size="12" color="#4B4B4B"> line=</font><font face="新宋体" size="12" color="#4B4B4B"><b>Console</b></font><font face="新宋体" size="12" color="#4B4B4B">::Read();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B"><b>List</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt; tokens;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">CopyFrom(tokens.Wrap(), lexer.Parse(line)&gt;&gt;Where(IsNotBlank));</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#4B4B4B"><b>TokenInput</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt; input(&amp;tokens[0], tokens.Count());</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF"><b>double</b></font><font face="新宋体" size="12" color="#4B4B4B"><b> result=exp.ParseFull(input, </b></font><font face="新宋体" size="12" color="#0000FF"><b>false</b></font><font face="新宋体" size="12" color="#4B4B4B"><b>);</b></font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B"><b>Console</b></font><font face="新宋体" size="12" color="#4B4B4B">::WriteLine(L</font><font face="新宋体" size="12" color="#A31515">&quot;Result is &quot;</font><font face="新宋体" size="12" color="#4B4B4B">+ftow(result));</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">是不是很容易写出来呢？不仅exp可以用来做分析，其实任何的Rule&lt;I, T&gt;都有一个ParseFull函数用来分析输入的记号列表。</font><br/></p><p><font face="Calibri" size="32" color="#000000"><b>错误恢复和定制错误信息</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">Vczh Library++对语法分析提供了强大的错误处理的支持。我们可以自由定制在语法规则的任意一点发生错误的时候应该采取的处理方法。我们可以</font><br/></p><p><font face="Wingdings" size="16" color="#4B4B4B"></font><font face="Times New Roman" size="9" color="#4B4B4B"> </font><font face="Calibri" size="16" color="#4B4B4B">记录一个错误并控制错误信息的文字内容</font><br/></p><p><font face="Wingdings" size="16" color="#4B4B4B"></font><font face="Times New Roman" size="9" color="#4B4B4B"> </font><font face="Calibri" size="16" color="#4B4B4B">决定恢复或者不恢复（构造一个假的分析结果）</font><br/></p><p><font face="Wingdings" size="16" color="#4B4B4B"></font><font face="Times New Roman" size="9" color="#4B4B4B"> </font><font face="Calibri" size="16" color="#4B4B4B">为了恢复错误，决定当前的迭代器应该跳过多少个记号</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">还是以那个例子为基础，对于tk(NUMBER)[Convert]，如果我们想在输入的迭代器所指向的位置不是一个数字的时候，想让分析立刻失败（分析器会自动尝试接下来的三个同一等级的规则，如果都失败，那么会采用这里的分析结果），那么可以将系统为这个错误自动生成的错误信息清除并使用我们自己的信息，然后返回一个值告诉系统说我不仅要自己定制错误信息，而且还不准备恢复：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B"><b>ParsingResult</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt; NeedExpression(</font><font face="新宋体" size="12" color="#4B4B4B"><b>TokenInput</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt;&amp; input, </font><font face="新宋体" size="12" color="#4B4B4B"><b>Types</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>TokenInput</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt;&gt;::</font><font face="新宋体" size="12" color="#4B4B4B"><b>GlobalInfo</b></font><font face="新宋体" size="12" color="#4B4B4B">&amp; globalInfo)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		globalInfo.errors.Clear();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		globalInfo.errors.Add(</font><font face="新宋体" size="12" color="#0000FF">new</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#4B4B4B"><b>CombinatorError</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>TokenInput</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt;&gt;(L</font><font face="新宋体" size="12" color="#A31515">&quot;Here needs an expression.&quot;</font><font face="新宋体" size="12" color="#4B4B4B">, input));</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#4B4B4B"><b>ParsingResult</b></font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#4B4B4B"><b>RegexToken</b></font><font face="新宋体" size="12" color="#4B4B4B">&gt;();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">}</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">于是我们可以在这个地方使用这个错误处理函数：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">tk(NUMBER)(</font><font face="新宋体" size="12" color="#FF0000"><b>NeedExpression</b></font><font face="新宋体" size="12" color="#4B4B4B">)[Convert]</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">Vczh Library++使用中括号插入结果转换函数，用小括号插入错误处理函数。因此我们可以挑选所有需要定制错误的地方，写出这些函数然后应用在规则上：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">ParsingResult&lt;RegexToken&gt; NeedOpenBrace(TokenInput&lt;RegexToken&gt;&amp; input, Types&lt;TokenInput&lt;RegexToken&gt;&gt;::GlobalInfo&amp; globalInfo)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		globalInfo.errors.Clear();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		globalInfo.errors.Add(</font><font face="新宋体" size="12" color="#0000FF">new</font><font face="新宋体" size="12" color="#4B4B4B"> CombinatorError&lt;TokenInput&lt;RegexToken&gt;&gt;(L</font><font face="新宋体" size="12" color="#A31515">&quot;Here needs a \&quot;(\&quot;.&quot;</font><font face="新宋体" size="12" color="#4B4B4B">, input));</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> ParsingResult&lt;RegexToken&gt;();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">ParsingResult&lt;RegexToken&gt; NeedCloseBrace(TokenInput&lt;RegexToken&gt;&amp; input, Types&lt;TokenInput&lt;RegexToken&gt;&gt;::GlobalInfo&amp; globalInfo)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		globalInfo.errors.Clear();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		globalInfo.errors.Add(</font><font face="新宋体" size="12" color="#0000FF">new</font><font face="新宋体" size="12" color="#4B4B4B"> CombinatorError&lt;TokenInput&lt;RegexToken&gt;&gt;(L</font><font face="新宋体" size="12" color="#A31515">&quot;Here needs an \&quot;)\&quot;.&quot;</font><font face="新宋体" size="12" color="#4B4B4B">, input));</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> ParsingResult&lt;RegexToken&gt;();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">ParsingResult&lt;RegexToken&gt; NeedOperator(TokenInput&lt;RegexToken&gt;&amp; input, Types&lt;TokenInput&lt;RegexToken&gt;&gt;::GlobalInfo&amp; globalInfo)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		globalInfo.errors.Clear();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		globalInfo.errors.Add(</font><font face="新宋体" size="12" color="#0000FF">new</font><font face="新宋体" size="12" color="#4B4B4B"> CombinatorError&lt;TokenInput&lt;RegexToken&gt;&gt;(L</font><font face="新宋体" size="12" color="#A31515">&quot;Here needs an operator.&quot;</font><font face="新宋体" size="12" color="#4B4B4B">, input));</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">return</font><font face="新宋体" size="12" color="#4B4B4B"> ParsingResult&lt;RegexToken&gt;();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	factor	= tk(NUMBER)(</font><font face="新宋体" size="12" color="#FF0000"><b>NeedExpression</b></font><font face="新宋体" size="12" color="#4B4B4B">)[Convert]</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			| (tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;-&quot;</font><font face="新宋体" size="12" color="#4B4B4B">) &gt;&gt; factor)[Negative]</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			| (tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;(&quot;</font><font face="新宋体" size="12" color="#4B4B4B">) &gt;&gt; exp &lt;&lt; tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;)&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)(</font><font face="新宋体" size="12" color="#FF0000"><b>NeedCloseBrace</b></font><font face="新宋体" size="12" color="#4B4B4B">))</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			| (tk(ID) + (tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;(&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)(</font><font face="新宋体" size="12" color="#FF0000"><b>NeedOpenBrace</b></font><font face="新宋体" size="12" color="#4B4B4B">) &gt;&gt; exp &lt;&lt; tk(L</font><font face="新宋体" size="12" color="#A31515">&quot;)&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)(</font><font face="新宋体" size="12" color="#FF0000"><b>NeedCloseBrace</b></font><font face="新宋体" size="12" color="#4B4B4B">)))[Call]</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	term		= lrec(factor + *(tk(MUL)(</font><font face="新宋体" size="12" color="#FF0000"><b>NeedOperator</b></font><font face="新宋体" size="12" color="#4B4B4B">) + factor), Operator);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">exp		= lrec(term + *(tk(ADD)(</font><font face="新宋体" size="12" color="#FF0000"><b>NeedOperator</b></font><font face="新宋体" size="12" color="#4B4B4B">) + term), Operator);</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">并不是所有的地方都需要我们亲自处理错误，我们只需要在需要自己定制错误消息的地方写上错误处理函数就好了。我们有一些简单的原则来寻找需要处理错误的地方。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">首先，一个规则的非第一分支的第一个记号不需要处理错误。这个很好处理，我们看factor，一共有四个分支。首先tk(NUMBER)是第一分支的第一个记号，而tk(L”-“)、tk(L”(“)和tk(ID)是非第一分支的的第一个记号。因为只要第一个分支处理了错误，那么非第一分支全部在第一个记号就失败的话，那么结果显然是采取第一个分支的错误结果。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">第二，大部分错误都集中在</font><font face="Calibri" size="16" color="#4B4B4B"><b>记号规则</b></font><font face="Calibri" size="16" color="#4B4B4B">上。记号规则说的是tk函数产生的规则。因为绝大多数错误信息都是在描述“这里需要XXX但是却没出现”，因此只需要在第一个原则所说的不需要错误信息的地方以外的所有记号规则出现的地方都写上自己的错误处理就可以了。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">第三，因为第一和第二个原则，因此所有非记号规则能产生的所有错误都被我们定制过了，因此非记号规则不需要任何错误处理，</font><font face="Calibri" size="16" color="#FF0000"><b>除非我们想定制能提供更多有用信息的错误信息，或者执行我们自己的错误恢复以便尽可能在错误产生的时候继续分析并产生多条有用的错误信息</b></font><font face="Calibri" size="16" color="#4B4B4B">。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">因此根据这三条原则，再加上我们这个例子只需要第一个错误信息，因此选中了那6个标记了红色的地方进行错误处理并输出我们自己的错误信息。</font><br/></p><p><font face="Calibri" size="32" color="#000000"><b>捕捉错误</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">最后的问题就是如何捕捉错误了。每一个Rule&lt;I, T&gt;都提供了一个Parse函数和ParseFull函数。Parse函数用于在输入的迭代器中寻找一个满足语法要求的最长前缀或者在遇到错误的时候给出有意义的错误列表。ParseFull则假定迭代器中的完整内容满足语法要求，然后进行分析或者在遇到错误的时候给出有意义的错误列表。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">Vczh Library++内部有一套用于将所有用户自定义的错误恢复机制所产生的错有可恢复错误挑选并组合起来的算法。因此在捕捉到错误的时候，第一个错误总是处于一个尽可能元的位置，而且基本上都是有意义的。Parse和ParseFull函数都直接返回我们需要的分析结果，或者在遇到错误的时候抛出一个CombinatorException&lt;I&gt;类型的异常。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">Parse和ParseFull的参数和结果如下：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">template</font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#0000FF">typename</font><font face="新宋体" size="12" color="#4B4B4B"> I, </font><font face="新宋体" size="12" color="#0000FF">typename</font><font face="新宋体" size="12" color="#4B4B4B"> O&gt;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">class</font><font face="新宋体" size="12" color="#4B4B4B"> Rule</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		O Parse(</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> I&amp; input, </font><font face="新宋体" size="12" color="#0000FF">bool</font><font face="新宋体" size="12" color="#4B4B4B"> allowError, I* remain=0)</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B">;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		O ParseFull(</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> I&amp; input, </font><font face="新宋体" size="12" color="#0000FF">bool</font><font face="新宋体" size="12" color="#4B4B4B"> allowError)</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B">;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">};</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">input参数是输入的迭代器。一般来说输入的迭代器的当前位置是第一个记号的位置，当然你也可以自己读了几个记号之后再传给Parse。 allowError为true的时候，如果分析出了错误但是所有错误都被用户自定义的错误恢复函数恢复了，也会返回分析结果而不会抛出异常。allowError为false的时候，只要有错误出现就会抛出异常。remain参数仅在Parse函数中有用，在分析结束之后，如果传入的指针不是空，那么对象会被修改为分析结束后迭代器的状态。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">如果分析出现错误并且需要被处理的话，那么Parse和ParseFUll都会抛出一个CombinatorException&lt;I&gt;的异常。CombinatorException&lt;I&gt;的定义如下：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">template</font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#0000FF">typename</font><font face="新宋体" size="12" color="#4B4B4B"> I&gt;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">class</font><font face="新宋体" size="12" color="#4B4B4B"> CombinatorException : </font><font face="新宋体" size="12" color="#0000FF">public</font><font face="新宋体" size="12" color="#4B4B4B"> Exception</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> I&amp; GetInput()</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B">;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">typename</font><font face="新宋体" size="12" color="#4B4B4B"> Types&lt;I&gt;::GlobalInfo&amp; GetGlobalInfo()</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B">;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">};</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">GetInput返回迭代器的当前状态。在所有错误都被恢复的时候，迭代器的当前状态是分析结束的时候迭代器的位置。一旦出现了没有被恢复的错误，那么迭代器的当前状态是Parse或者ParseFull输入的迭代器状态。GetGlobalInfo返回的对象有errorList与candidateErrorList两个列表，分别是错误和备选错误。他们的元素类型都是Ptr&lt;CombinatorError&lt;I&gt;&gt;。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">CombinatorError&lt;I&gt;的定义如下：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">template</font><font face="新宋体" size="12" color="#4B4B4B">&lt;</font><font face="新宋体" size="12" color="#0000FF">typename</font><font face="新宋体" size="12" color="#4B4B4B"> I&gt;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">class</font><font face="新宋体" size="12" color="#4B4B4B"> CombinatorError : </font><font face="新宋体" size="12" color="#0000FF">public</font><font face="新宋体" size="12" color="#4B4B4B"> Exception</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">public</font><font face="新宋体" size="12" color="#4B4B4B">:</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">typedef</font><font face="新宋体" size="12" color="#4B4B4B"> </font><font face="新宋体" size="12" color="#0000FF">typename</font><font face="新宋体" size="12" color="#4B4B4B"> Types&lt;I&gt;::Input			InputType;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> InputType&amp; GetPosition();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">};</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">而Exception的定义如下：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">class</font><font face="新宋体" size="12" color="#4B4B4B"> Exception : </font><font face="新宋体" size="12" color="#0000FF">public</font><font face="新宋体" size="12" color="#4B4B4B"> Object</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">public</font><font face="新宋体" size="12" color="#4B4B4B">:</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> WString&amp; Message()</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B">;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">};</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">我们可以通过Message()函数获得错误信息的文字内容，然后通过GetPosition()函数获得错误发生的时候迭代器的状态。于是我们不仅可以知道出现了多少错误，还能知道这些错误时分别在什么地方出现的。</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">于是让我们来看一看带函数的四则运算计算器应该如何处理用户输入的表达式在分析过程中产生的错误：</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	Console::Write(L</font><font face="新宋体" size="12" color="#A31515">&quot;\r\nexpression&gt;&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	WString line=Console::Read();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(line==L</font><font face="新宋体" size="12" color="#A31515">&quot;&quot;</font><font face="新宋体" size="12" color="#4B4B4B">)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">break</font><font face="新宋体" size="12" color="#4B4B4B">;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">try</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		List&lt;RegexToken&gt; tokens;</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		CopyFrom(tokens.Wrap(), lexer.Parse(line)&gt;&gt;Where(IsNotBlank));</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">for</font><font face="新宋体" size="12" color="#4B4B4B">(</font><font face="新宋体" size="12" color="#0000FF">int</font><font face="新宋体" size="12" color="#4B4B4B"> i=0;i&lt;tokens.Count();i++)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(tokens[i].token==-1)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">				</font><font face="新宋体" size="12" color="#0000FF">throw</font><font face="新宋体" size="12" color="#4B4B4B"> Exception(L</font><font face="新宋体" size="12" color="#A31515">&quot;Syntax error. Unknown token: \&quot;&quot;</font><font face="新宋体" size="12" color="#4B4B4B">+WString(tokens[i].reading, tokens[i].length)+L</font><font face="新宋体" size="12" color="#A31515">&quot;\&quot;.&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(tokens.Count()==0)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">throw</font><font face="新宋体" size="12" color="#4B4B4B"> Exception(L</font><font face="新宋体" size="12" color="#A31515">&quot;Syntax error. Expression cannot be empty.&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">try</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			TokenInput&lt;RegexToken&gt; input(&amp;tokens[0], tokens.Count());</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">double</font><font face="新宋体" size="12" color="#4B4B4B"> result=exp.ParseFull(input, </font><font face="新宋体" size="12" color="#0000FF">false</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			Console::WriteLine(L</font><font face="新宋体" size="12" color="#A31515">&quot;Result is &quot;</font><font face="新宋体" size="12" color="#4B4B4B">+ftow(result));</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		</font><font face="新宋体" size="12" color="#0000FF">catch</font><font face="新宋体" size="12" color="#4B4B4B">(</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> CombinatorException&lt;TokenInput&lt;RegexToken&gt;&gt;&amp; e)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			Ptr&lt;CombinatorError&lt;TokenInput&lt;RegexToken&gt;&gt;&gt; error=e.GetGlobalInfo().errors.Get(0);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> TokenInput&lt;RegexToken&gt;&amp; position=error-&gt;GetPosition();</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">if</font><font face="新宋体" size="12" color="#4B4B4B">(position.Available())</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">				</font><font face="新宋体" size="12" color="#0000FF">throw</font><font face="新宋体" size="12" color="#4B4B4B"> Exception(L</font><font face="新宋体" size="12" color="#A31515">&quot;Syntax error. &quot;</font><font face="新宋体" size="12" color="#4B4B4B">+error-&gt;Message()+L</font><font face="新宋体" size="12" color="#A31515">&quot; First occurs at \&quot;&quot;</font><font face="新宋体" size="12" color="#4B4B4B">+WString(position.Current().reading)+L</font><font face="新宋体" size="12" color="#A31515">&quot;\&quot;.&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			</font><font face="新宋体" size="12" color="#0000FF">else</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">				</font><font face="新宋体" size="12" color="#0000FF">throw</font><font face="新宋体" size="12" color="#4B4B4B"> Exception(L</font><font face="新宋体" size="12" color="#A31515">&quot;Syntax error. Expression is not complete.&quot;</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">			}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	}</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	</font><font face="新宋体" size="12" color="#0000FF">catch</font><font face="新宋体" size="12" color="#4B4B4B">(</font><font face="新宋体" size="12" color="#0000FF">const</font><font face="新宋体" size="12" color="#4B4B4B"> Exception&amp; e)</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">	{</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		Console::SetColor(</font><font face="新宋体" size="12" color="#0000FF">true</font><font face="新宋体" size="12" color="#4B4B4B">, </font><font face="新宋体" size="12" color="#0000FF">false</font><font face="新宋体" size="12" color="#4B4B4B">, </font><font face="新宋体" size="12" color="#0000FF">false</font><font face="新宋体" size="12" color="#4B4B4B">, </font><font face="新宋体" size="12" color="#0000FF">true</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		Console::WriteLine(e.Message());</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">		Console::SetColor(</font><font face="新宋体" size="12" color="#0000FF">true</font><font face="新宋体" size="12" color="#4B4B4B">, </font><font face="新宋体" size="12" color="#0000FF">true</font><font face="新宋体" size="12" color="#4B4B4B">, </font><font face="新宋体" size="12" color="#0000FF">true</font><font face="新宋体" size="12" color="#4B4B4B">, </font><font face="新宋体" size="12" color="#0000FF">false</font><font face="新宋体" size="12" color="#4B4B4B">);</font><br/></p><p><font face="新宋体" size="12" color="#4B4B4B">}</font><br/></p><p><font face="Calibri" size="32" color="#000000"><b>结束</b></font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">使用Vczh Library++开发语法分析器的指南就到此结束了。如果在阅读过程中有什么疑问的话可以使用如下方法来找到我：</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">电子邮件：</font><font face="Calibri" size="16" color="#0000FF">vczh@163.com</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">博客：</font><font face="Calibri" size="16" color="#800080">http://www.cppblog.com/vczh</font><br/></p><p><font face="Calibri" size="16" color="#4B4B4B">Vczh Library++项目主页：</font><font face="Calibri" size="16" color="#800080">http://vlpp.codeplex.com</font><br/></p></Content></Doc>